// Generated by CoffeeScript 1.6.3
(function() {
  "Helper classes, moved out of the main folder for ease of navigation. Each should really go in its own file if\n  the project becomes large.\n\nCompile by running coffee -wc *.coffee to generate main.js and compile other .coffee files in the directory.";
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.EmotionProcessor = (function() {
    function EmotionProcessor() {}

    EmotionProcessor.makeQuizChoices = function(actualEmoticon) {
      "Creates a list of emoticon quiz choices, where the other emoticon choices do not express the\nsame emotion as the actual emoticon, or the same emotion as each other.";
      var allChoices, choice, choiceContext;
      EmotionProcessor.wrongChoices = EmotionProcessor.chooseEmotionsExcept(actualEmoticon, NUMBER_WRONG_CHOICES);
      allChoices = _.clone(EmotionProcessor.wrongChoices);
      allChoices.push(actualEmoticon);
      allChoices = _.shuffle(allChoices);
      choiceContext = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = allChoices.length; _i < _len; _i++) {
          choice = allChoices[_i];
          _results.push({
            "emoticon": choice,
            "correct": choice === actualEmoticon ? "correct" : "wrong"
          });
        }
        return _results;
      })();
      return choiceContext;
    };

    EmotionProcessor.getEmoticon = function(msg) {
      var emoticons, emotion, face, faces, _i, _len;
      emoticons = [];
      for (emotion in EMOTICON_MAP) {
        faces = EMOTICON_MAP[emotion];
        for (_i = 0, _len = faces.length; _i < _len; _i++) {
          face = faces[_i];
          if (msg.indexOf(face) !== -1) {
            if (emoticons.length === 0 || face.length > emoticons[emoticons.length - 1]) {
              emoticons.push(face);
            }
          }
        }
      }
      if (emoticons.length === 0) {
        return null;
      }
      return emoticons[emoticons.length - 1];
    };

    EmotionProcessor.countEmoticons = function(msg) {
      var count, _ref;
      _ref = EmotionProcessor.redactEmoticons(msg), msg = _ref[0], count = _ref[1];
      return count;
    };

    EmotionProcessor.redactEmoticons = function(msg) {
      var count, face;
      console.log("redacting msg");
      count = 0;
      while (true) {
        face = EmotionProcessor.getEmoticon(msg);
        if (face === null) {
          console.log(msg);
          return [msg, count];
        }
        count += 1;
        msg = msg.slice(0, msg.indexOf(face)) + "[?]" + msg.slice(msg.indexOf(face) + face.length);
      }
    };

    EmotionProcessor.numberOfEmotions = function() {
      return Object.keys(EMOTICON_MAP).length;
    };

    EmotionProcessor.chooseEmotionsExcept = function(illegalFaceEmotion, numberToChoose) {
      "Returns a list of numberToChoose emoticons, none of which express the same emotion as illegalFaceEmotion emoticon,\nnor the same emotion as each other.";
      var chosenEmotions, chosenFaces, key, legalKeys;
      legalKeys = (function() {
        var _i, _len, _ref, _results;
        _ref = Object.keys(EMOTICON_MAP);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          if (__indexOf.call(EMOTICON_MAP[key], illegalFaceEmotion) < 0) {
            _results.push(key);
          }
        }
        return _results;
      })();
      chosenEmotions = _.sample(legalKeys, numberToChoose);
      chosenFaces = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = chosenEmotions.length; _i < _len; _i++) {
          key = chosenEmotions[_i];
          _results.push(_.sample(EMOTICON_MAP[key], 1)[0]);
        }
        return _results;
      })();
      return chosenFaces;
    };

    return EmotionProcessor;

  }).call(this);

  window.VideoRecorder = (function() {
    "Handles the mechanics of recording videos every 3 seconds.";
    function VideoRecorder() {
      this.dataAvailableCallback = __bind(this.dataAvailableCallback, this);
      this.mediaSuccessCallback = __bind(this.mediaSuccessCallback, this);
      this.connectWebcam = __bind(this.connectWebcam, this);
      this.curVideoBlob = null;
    }

    VideoRecorder.prototype.connectWebcam = function() {
      var mediaConstraints, onMediaError, onMediaSuccess,
        _this = this;
      mediaConstraints = {
        video: true,
        audio: false
      };
      onMediaSuccess = this.mediaSuccessCallback;
      onMediaError = function(e) {
        return console.error('media error', e);
      };
      return navigator.getUserMedia(mediaConstraints, onMediaSuccess, onMediaError);
    };

    VideoRecorder.prototype.mediaSuccessCallback = function(videoStream) {
      var mediaRecorder, second_counter, second_counter_update, time, video, video_height, video_width, webcam_stream,
        _this = this;
      video_width = 160;
      video_height = 120;
      webcam_stream = document.getElementById('webcam_stream');
      video = document.createElement('video');
      webcam_stream.innerHTML = "";
      video = mergeProps(video, {
        controls: false,
        width: video_width,
        height: video_height,
        src: URL.createObjectURL(videoStream)
      });
      video.play();
      webcam_stream.appendChild(video);
      time = 0;
      second_counter = document.getElementById('second_counter');
      second_counter_update = setInterval(function() {
        return second_counter.innerHTML = time++;
      }, 1000);
      mediaRecorder = new MediaStreamRecorder(videoStream);
      mediaRecorder.mimeType = 'video/webm';
      mediaRecorder.video_width = video_width / 2;
      mediaRecorder.video_height = video_height / 2;
      mediaRecorder.ondataavailable = this.dataAvailableCallback;
      setInterval(function() {
        mediaRecorder.stop();
        return mediaRecorder.start(VIDEO_LENGTH_MS);
      }, VIDEO_LENGTH_MS);
      return console.log("connect to media videoStream!");
    };

    VideoRecorder.prototype.dataAvailableCallback = function(blob) {
      var _this = this;
      _this = this;
      return BlobConverter.blob_to_base64(blob, function(b64_data) {
        return _this.curVideoBlob = b64_data;
      });
    };

    return VideoRecorder;

  })();

  window.BlobConverter = (function() {
    "Static methods for converting blob to base 64 and vice versa\nfor performance bench mark, please refer to http://jsperf.com/blob-base64-conversion/5\nnote useing String.fromCharCode.apply can cause callstack error";
    function BlobConverter() {}

    BlobConverter.blob_to_base64 = function(blob, callback) {
      var reader;
      reader = new FileReader();
      reader.onload = function() {
        var base64, dataUrl;
        dataUrl = reader.result;
        base64 = dataUrl.split(',')[1];
        return callback(base64);
      };
      return reader.readAsDataURL(blob);
    };

    BlobConverter.base64_to_blob = function(base64) {
      var binary, blob, buffer, i, len, view, _i;
      binary = atob(base64);
      len = binary.length;
      buffer = new ArrayBuffer(len);
      view = new Uint8Array(buffer);
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        view[i] = binary.charCodeAt(i);
      }
      blob = new Blob([view]);
      return blob;
    };

    return BlobConverter;

  }).call(this);

}).call(this);
